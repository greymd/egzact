--
-- This file has been auto-generated by egison-translator.
--

ARGMAX := 65535

ESCAPETARGET := "\\\""

S.isNats str := not (isEmpty (regex "^[1-9][0-9]*$" str))

argsCheckOpts := \opts => (~opts & ?1#(checkOpts %1)) ++ []

argsCheckOptsNum :=
  \opts arg => (~opts & ?1#(checkOpts %1)) ++ (~arg & ?1#(S.isNats %1)) :: []

argsCheckOptsStr := \opts arg => (~opts & ?1#(checkOpts %1)) ++ ~arg :: []

checkOpts opts :=
  match opts as (list string) with
    | [] -> True
    | loop $n (1, length opts, _)
        (?1#(not (isEmpty (regex "=" %1))) :: ...)
        [] -> True
    | _ -> False

numValidation num :=
  if isInteger num
    then if num > 0 then min [num, ARGMAX] else ARGMAX
    else if isString num then min [read num, ARGMAX] else ARGMAX

optionUsage :=
  do print "OPTIONS:"
     print "    fs=STR     Field separator."
     print "    ifs=STR    Input field separator."
     print "    ofs=STR    Output field separator."
     print "    eor=STR    End of record."
     print "    eos=STR    End of set."

optionUsage2 :=
  do print "OPTIONS:"
     print "    eor=STR    End of record."
     print "    eos=STR    End of set."

execution thisPrinter thisFilter thisOpts thisArg thisInput :=
  let (IFS, OFS, EOR, EOS, EOF) := setDefaultOpts (opts2hash thisOpts)
   in thisPrinter thisFilter thisArg IFS OFS EOR EOS EOF thisInput

setDefaultOpts opts :=
  ( setDefaultValue [opts "ifs", opts "fs", " "]
  , setDefaultValue [opts "ofs", opts "fs", " "]
  , setDefaultValue [opts "eor", "\n"]
  , setDefaultValue2 [opts "eos", "\n"]
  , setDefaultValue [opts "eof", "\n"] )

stdin := takeWhile 1#(not (EOF = %1)) (recursiveRead readLine)

recursiveRead proc :=
  (if io isEof () then EOF else io proc ()) :: recursiveRead proc

printWholeInput FILTER ARGS IFS OFS EOR EOS EOF INF :=
  each
    1#(write (S.append (joinString OFS %1) EOR))
    (FILTER ARGS (splitWholeInput IFS INF))

printEachLine FILTER ARGS IFS OFS EOR EOS EOF INF :=
  each
    write
    (intersperse2
       EOS
       (map
          1#(twocol2string OFS EOR %1)
          (map (FILTER ARGS %1) (splitEachLine IFS INF))) ++ [EOF])

setDefaultValue ls :=
  match ls as list something with
    | _ ++ ($x & !#() & ?1#(isString %1)) :: $xs -> (x)

setDefaultValue2 ls :=
  match ls as list something with
    | ($x & !#() & ?1#(isString %1)) :: $xs -> (S.concat ["\n", x, "\n"])
    | _ -> (setDefaultValue ls)


opts2hash args :=
    read $ S.concat [ "\\match as something with\n"
    , S.concat (map 1#(3#(S.concat [
        "  | #"
        , show (escapeString %1),
        " -> ",
        show (escapeString %3),
        "\n"]) $ head $ regex "=" %1) args)
    , "  | _ -> []\n"
    ]

twocol2string fieldSep rowSep cols :=
  joinString rowSep (map 1#(joinString fieldSep %1) cols)

escapeChars target :=
  \match as list char with
    | [] -> []
    | ($c & #target) :: $cs -> ['\\', c] ++ (escapeChars target) cs
    | $c :: $cs -> [c] ++ (escapeChars target) cs

escapeString target :=
  pack (foldl 2#((escapeChars %2) %1) (unpack target) (unpack ESCAPETARGET))

joinString fs ls :=
  match ls as list string with
    | [] -> ""
    | ($lst & ?1#(isString %1)) :: [] -> lst
    | $x :: $xs -> (S.append (S.append x fs) (joinString fs xs))

S.split2 delim ls :=
  if S.isEmpty delim then map 1#(pack [%1]) (unpack ls) else S.split delim ls

splitWholeInput str line :=
  match line as list string with
    | [] -> []
    | $x :: $xs -> concat [S.split2 str x, splitWholeInput str xs]

splitEachLine str line :=
  match line as list string with
    | [] -> []
    | $x :: $xs -> [S.split2 str x] ++ splitEachLine str xs

intersperse2 str line :=
  match line as list string with
    | $x :: [] -> [x]
    | $x :: $xs -> ([x] ++ [str]) ++ intersperse2 str xs
