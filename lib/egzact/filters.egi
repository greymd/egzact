(define $PHOLDER "\\*")

(define $filter-plain
  (lambda [$str $line]
    {line}))

(define $filter-addl
  (lambda [$str $line]
    {(cons str line)}))

(define $filter-addr
  (lambda [$str $line]
    {(append line {str})}))

(define $filter-mirror
  (lambda [$str $line]
    {(reverse line)}))

(define $filter-obrev
  (lambda [$str $line]
    {line (reverse line)}))

(define $filter-cycle
  (lambda [$num $line]
    (match-all line (list string)
      [<join (& $x _) (& $xs !<nil>)>
       [(concat {xs x})]])))

(define $filter-comb
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      (match-all line (list string)
        [(loop $i [1 min-num]
               <join _ <cons $a_i ...>>
               _)
        (map (1#a_%1 $) (between 1 min-num))]))))

(define $filter-perm
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      (match-all line (multiset string)
        [(loop $i [1 min-num]
               <cons $a_i ...>
               _)
        (map (1#a_%1 $) (between 1 min-num))]))))

(define $filter-conv-each
  (lambda [$num $line]
    (filter-conv [(min [num (length line)]) line])))

(define $filter-conv
  (lambda [$num $line]
    (match-all line (list string)
      [<join _ (loop $i [1 num]
                     <cons $a_i ...>
                     _) >
             (map (1#a_%1 $) (between 1 num))])))

(define $filter-dupl
  (lambda [$num $line]
    (take num (repeat1 line))))

(define $filter-flat
  (lambda [$num $line]
    (match line (list string) {
                               [(loop $i [1 num] <cons $a_i ...> $xs)
                                {(map 1#a_%1 (between 1 num)) @(filter-flat num xs)}]
                               [<join $x <cons $xs <nil>>> {(append x {xs})}]
                               [<nil> {}]
                               })))

(define $filter-slit
  (lambda [$num $line]
    (letrec {[$exec-partition
               (lambda [$part-nums $ls]
                 (match ls (list integer)
                   {
                   [<nil> {}]
                   [(loop $n [1 (car part-nums)] <cons $a_n ...> $rest)
                    [(concat
                       {{(map (1#a_%1 $) (between 1 (car part-nums)))}
                       (exec-partition (cdr part-nums) rest)})]]
                   }))
               ]}
      (exec-partition
        (equalized-partition-nums (length line) num)
        line))))

; Devide a number into the collection which has "num-length" of elements.
; Returns a "integer partition" which equalized each element as much as possible.
; (equalized-partition-nums 100 10); => {10 10 10 10 10 10 10 10 10 10}
; (equalized-partition-nums 100 6); => {17 17 17 17 16 16}
(define $equalized-partition-nums
  (lambda [$num $num-length]
  (let* {
        [$upper-num (ceiling (rtof (/ num num-length)))]
        [$lower-num (- upper-num 1)]
        [$lower-num-count (- (* upper-num num-length) num)]
        [$upper-num-count (- num-length lower-num-count)]}
        (concat
          {(take upper-num-count (repeat1 upper-num))
          (take lower-num-count (repeat1 lower-num))}))))

(define $filter-subsets
  (lambda [$empty $line]
    (match-all line (list string)
      [<join _ <join (& $x !<nil>) _>>
       {@x}])))

(define $filter-stairl
  (lambda [$empty $line]
    (match-all line (list string) [<join (& $x !<nil>) $xs> [x]])))

(define $filter-stairr
  (lambda [$empty $line]
    (match-all line (list string) [<nioj (& $x !<nil>) $xs> [x]])))

(define $filter-takel
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(take min-num line)})))

(define $filter-taker
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(drop (- (length line) min-num) line)})))

(define $filter-takelx
  (lambda [$str $line]
    {(match line (list string) {[<join $left <cons (& $elem ?1#(not (empty? (regex str %1))) !<nil>) _>>
                                 (append left {elem})]
                                [_ {}] ;If there is no mached patterns.
                                })}))

(define $filter-takerx
  (lambda [$str $line]
    {(match line (list string) {[<nioj $right <snoc (& $elem ?1#(not (empty? (regex str %1))) !<nil>) _>>
                                 (append {elem} right)]
                                [_ {}] ;If there is no mached patterns.
                                })}))

(define $filter-dropl
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(drop min-num line)})))

(define $filter-dropr
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(take (- (length line) min-num) line)})))

(define $filter-zrep
  (lambda [$str $line]
    {(match line (list string) {[ <join $left <cons (& $elem ?1#(not (empty? (regex str %1))) !<nil>) $right>>
                                        (concat {{elem} @(filter-zrep str right)})]
       [_ {}] ;If there is no mached patterns.
       })}))

(define $filter-zniq
  (lambda [$str $line]
    {(unique/m string line)}))

(define $filter-wrap
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
      (filter-wrap-impl pre suf line))))

(define $filter-wrap-impl
  (lambda [$pre $suf $line]
    {(match line (list string) {[ <join _ <cons $elem $right>>
                                        (concat {{(S.concat {pre elem suf})} @(filter-wrap-impl pre suf right)})]
       [_ {}] ;If there is no mached patterns.
       })}))

(define $filter-nestl
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
     {(foldl 2#(concat {{pre} %1 {%2} {suf}}) {} line)})))

(define $filter-nestr
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
     {(foldr 2#(concat {{pre} {%1} %2 {suf}}) {} line)})))

(define $filter-crops
  (lambda [$str $line]
    (unique/m (list string)
    (extract-mached-str
      (remove-empty-element
        (match-all line (list string)[<join _ <join (& $x !<nil>) _>>
                                            (regex str (S.concat x))]))))))

(define $remove-empty-element
  (lambda [$results]
    (filter 1#(not (empty? %1)) results)))

(define $extract-mached-str
  (lambda [$results]
    (map 1#(3#{%2} %1)
         (map 1#(car %1) results))))
