(define $PHOLDER "\\*")

(define $filter-plain
  (lambda [$str $line]
    {line}))

(define $filter-addl
  (lambda [$str $line]
    {(cons str line)}))

(define $filter-addr
  (lambda [$str $line]
    {(append line {str})}))

(define $filter-mirror
  (lambda [$str $line]
    {(reverse line)}))

(define $filter-orirev
  (lambda [$str $line]
    {line (reverse line)}))

(define $filter-cycle
  (lambda [$num $line]
    (match-all line (list string)
      [<join (& $x _) (& $xs !<nil>)>
       [(concat {xs x})]])))

(define $filter-comb
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      (match-all line (list string)
        [(loop $i [1 min-num]
               <join _ <cons $a_i ...>>
               _)
        (map (1#a_%1 $) (between 1 min-num))]))))

(define $filter-perm
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      (match-all line (multiset string)
        [(loop $i [1 min-num]
               <cons $a_i ...>
               _)
        (map (1#a_%1 $) (between 1 min-num))]))))

(define $filter-conv-each
  (lambda [$num $line]
    (filter-conv [(min [num (length line)]) line])))

(define $filter-conv
  (lambda [$num $line]
    (match-all line (list string)
      [<join _ (loop $i [1 num]
                     <cons $a_i ...>
                     _) >
             (map (1#a_%1 $) (between 1 num))])))

(define $filter-dupl
  (lambda [$num $line]
    (take num (repeat1 line))))

(define $filter-flat
  (lambda [$num $line]
    (match line (list string) {
                               [(loop $i [1 num] <cons $a_i ...> $xs)
                                {(map 1#a_%1 (between 1 num)) @(filter-flat num xs)}]
                               [<join $x <cons $xs <nil>>> {(append x {xs})}]
                               [<nil> {}]
                               })))

(define $filter-subsets
  (lambda [$empty $line]
    (match-all line (list string)
      [<join _ <join (& $x !<nil>) _>>
       {@x}])))

(define $filter-stairl
  (lambda [$empty $line]
    (match-all line (list string) [<join (& $x !<nil>) $xs> [x]])))

(define $filter-stairr
  (lambda [$empty $line]
    (match-all line (list string) [<nioj (& $x !<nil>) $xs> [x]])))

(define $filter-takel
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(take min-num line)})))

(define $filter-taker
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(drop (- (length line) min-num) line)})))

(define $filter-takelx
  (lambda [$str $line]
    {(match line (list string) {[<join $left <cons (& $elem ?1#(not (empty? (regex str %1))) !<nil>) _>>
                                 (append left {elem})]
                                [_ {}] ;If there is no mached patterns.
                                })}))

(define $filter-takerx
  (lambda [$str $line]
    {(match line (list string) {[<nioj $right <snoc (& $elem ?1#(not (empty? (regex str %1))) !<nil>) _>>
                                 (append {elem} right)]
                                [_ {}] ;If there is no mached patterns.
                                })}))

(define $filter-dropl
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(drop min-num line)})))

(define $filter-dropr
  (lambda [$num $line]
    (let {[$min-num (min [num (length line)])]}
      {(take (- (length line) min-num) line)})))

(define $filter-zrep
  (lambda [$str $line]
    {(match line (list string) {[ <join $left <cons (& $elem ?1#(not (empty? (regex str %1))) !<nil>) $right>>
                                        (concat {{elem} @(filter-zrep str right)})]
       [_ {}] ;If there is no mached patterns.
       })}))

(define $filter-zniq
  (lambda [$str $line]
    {(unique/m string line)}))

(define $filter-wrap
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
      (filter-wrap-impl pre suf line))))

(define $filter-wrap-impl
  (lambda [$pre $suf $line]
    {(match line (list string) {[ <join _ <cons $elem $right>>
                                        (concat {{(S.concat {pre elem suf})} @(filter-wrap-impl pre suf right)})]
       [_ {}] ;If there is no mached patterns.
       })}))

(define $filter-nestl
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
     {(foldl 2#(concat {{pre} %1 {%2} {suf}}) {} line)})))

(define $filter-nestr
  (lambda [$str $line]
    (let {[[$pre $pl $suf] (car (regex PHOLDER str))]}
     {(foldr 2#(concat {{pre} {%1} %2 {suf}}) {} line)})))

; {["a" "b"] ["c" "d"]} => {"a" "b" "c" "d"}
(define $tuplecol2col
  (lambda [$ls]
    (match ls (list [string string]) {
                                    [<cons [$fst $snd] $rest> (concat {{fst snd} (tuplecol2col rest)})]
                                    [<nil> {}]
                                    })))

(define $filter-crops
  (lambda [$str $line]
    (unique/m (list string)
    (extract-mached-str
      (remove-empty-element
        (match-all line (list string)[<join _ <join (& $x !<nil>) _>>
                                            (regex str (S.concat x))]))))))

(define $remove-empty-element
  (lambda [$results]
    (filter 1#(not (empty? %1)) results)))

(define $extract-mached-str
  (lambda [$results]
    (map 1#(3#{%2} %1)
         (map 1#(car %1) results))))
