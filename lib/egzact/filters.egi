--
-- This file has been auto-generated by egison-translator.
--

PHOLDER := "\\*"

filterPlain str line := [line]

filterAddl str line := [str :: line]

filterAddr str line := [line ++ [str]]

filterMirror str line := [reverse line]

filterObrev str line := [line, reverse line]

filterCycle num line :=
  matchAll line as list string with
    | ($x & _) ++ ($xs & ![]) -> (concat [xs, x])

filterComb num line :=
  let minNum := min (num, length line)
   in matchAll line as list string with
        | loop $i (1, minNum)
            (_ ++ $a_i :: ...)
            _ -> map (\n -> a_n) (between 1 minNum)

filterPerm num line :=
  let minNum := min (num, length line)
   in matchAll line as multiset string with
        | loop $i (1, minNum, _)
            ($a_i :: ...)
            _ -> map 1#(1#a_%1 %1) (between 1 minNum)

filterConvEach num line := filterConv (min (num, length line), line)

filterConv num line :=
  matchAll line as list string with
    | _ ++ (loop $i (1, num, _)
              ($a_i :: ...)
              _) -> map 1#(1#a_%1 %1) (between 1 num)

filterDupl num line := take num (repeat1 line)

filterFlat num line :=
  match line as list string with
    | loop $i (1, num, _)
        ($a_i :: ...)
        $xs -> map 1#a_%1 (between 1 num) :: filterFlat num xs
    | $x ++ $xs :: [] -> [x ++ [xs]]
    | [] -> []

filterSlit num line :=
  let execPartition partNums ls :=
        match ls as list integer with
          | [] -> []
          | loop $n (1, head partNums, _)
              ($a_n :: ...)
              $rest ->
            concat
              [ [map 1#(1#a_%1 %1) (between 1 (head partNums))]
              , execPartition (tail partNums) rest ]
   in execPartition (equalizedPartitionNums (length line) num) line

equalizedPartitionNums num numLength :=
  let upperNum := ceiling (rtof (num / numLength))
      lowerNum := upperNum - 1
      lowerNumCount := upperNum * numLength - num
      upperNumCount := numLength - lowerNumCount
   in concat
        [ take upperNumCount (repeat1 upperNum)
        , take lowerNumCount (repeat1 lowerNum) ]

filterSublist empty line :=
  matchAll line as list string with
    | _ ++ ($x & ![]) ++ _ -> x

filterSubset empty line :=
  matchAll line as set string with
    | ($x & ![]) ++ _ -> x

filterStairl empty line :=
  matchAll line as list string with
    | ($x & ![]) ++ $xs -> (x)

filterStairr empty line :=
  matchAll line as list string with
    | nioj ($x & ![]) $xs -> (x)

filterTakel num line :=
  let minNum := min (num, length line)
   in [(take minNum line)]

filterTaker num line :=
  let minNum := min (num, length line)
   in [drop (length line - minNum) line]

filterTakelx str line :=
  [ match line as list string with
    | $left ++ ($elem & ?(\n -> not (isEmpty (regex str n))) & ![]) :: _ ->
      left ++ [elem]
    | _ -> [] ]

filterTakerx str line :=
  [ match line as list string with
    | nioj $right (snoc ($elem & ?(\n -> not (isEmpty (regex str n))) & ![]) _) ->
      [elem] ++ right
    | _ -> [] ]

filterDropl num line :=
  let minNum := min (num, length line)
   in [drop minNum line]

filterDropr num line :=
  let minNum := min (num, length line)
   in [take (length line - minNum) line]

filterZrep str line :=
  [ match line as list string with
    | $left ++ ($elem & ?(\n -> not (isEmpty (regex str n))) & ![]) :: $right ->
      concat ([elem] :: filterZrep str right)
    | _ -> [] ]

filterZniq str line := [uniqueAs string line]

filterWrap str line :=
  let (pre, pl, suf) := head (regex PHOLDER str)
   in filterWrapImpl pre suf line

filterWrapImpl pre suf line :=
  [ match line as list string with
    | _ ++ $elem :: $right ->
      concat ([S.concat [pre, elem, suf]] :: filterWrapImpl pre suf right)
    | _ -> [] ]

filterNestl str line :=
  let (pre, pl, suf) := head (regex PHOLDER str)
   in [foldl 2#(concat [[pre], %1, [%2], [suf]]) [] line]

filterNestr str line :=
  let (pre, pl, suf) := head (regex PHOLDER str)
   in [foldr 2#(concat [[pre], [%1], %2, [suf]]) [] line]

filterCrops str line :=
  uniqueAs
    (list string)
    (extractMachedStr
       (removeEmptyElement
          (matchAll line as list string with
            | _ ++ ($x & ![]) ++ _ -> regex str (S.concat x))))

removeEmptyElement results := filter (\n -> not (isEmpty n)) results

extractMachedStr results := map (\elem -> 3#[%2] elem) (map 1#(head %1) results)
